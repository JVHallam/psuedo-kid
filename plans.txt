This time, we will complete the program.
Minor notes:
	Calculating the index of the start of an area:
		Area_starts:
			Column:
				column_start_index = current_index % 9;

			Row:
				row_start_index = (current_index / 9) * 9;

			Chamber:
				chamber_start_index = row_start_index + column_start_index;

		Indexes:
			Chamber:
				chamber_index = ((row_index / 3) * 3) + (col_index % 3);


It will be broken down into 2 main sections:	
	Traversal 

	Logical Evaluation


Traversal:
	grid_traversal:
		Purpose of the function:
			To navigate to the start of a row, column or chamber and return a pointer to that cell.
			Alternatively, just navigates to a cell of the index.

			Input:
				choice:
					row, column, chamber, cell

				index:
					with the first 3, take a value from 0 - 8 and return the pointer to that index

					with the last, take a value from 0 - 80.

				grid start:
					Take a pointer to the start of the grid.

	get_area_start (formerly, get_start_of_area or something similar):
		purpose:	
			gets the cell at the start of the area we are in.

			input:
				int* to our current cell.

				choice:
					do we want the chamber, cell or row start.

				int* to the start of the board.

		possible implementation:
			int cell_index = cell_ptr - board_ptr;

			From there, calculate which chamber, row or column we're in.

			pass that to grid_traversal.

	get_area:
		purpose:
			returns an int* array of 9 values, pointing to the cells that we request.
			That way, the logical evaluation functions don't have to deal with any real traversal of the grid.

		takes:
			cell*
				Doesn't take start of area pointer, as it will be calling start_of_area to get that pointer itself.

			choice

			grid_start pointer

Final thoughts on traversal:
	There has to be a way to tie 2 or all 3 of these together, so that i'm micro managing them as least as possible.

	I don't think i ever need to call start of area directly.

	grid_traversal can be used to cycle the grid. I'll only ever call start_of_area to get the start of the area i'm looking at.

	get_area can use start of area and then during the stages of the logic analysis, i can just use get_area and grid_traversal.


Logical Evalutation:
	This section basically just looks at an area and deems whether or not it has a cell, that is appropriate to hold a value.

	functions:
		is_present:
			purpose:
				to take the pointer to an area and checks if a value is present.
				return true or false.

				input:
					int* area
					value

		is_appropriate:
			purpose:
				check if a cell is appropriate to hold a value.
				performs is_present on that cells: row, column and chamber.

			takes:
				grid_start pointer

				value

				int* cell

		solve_area:
			purpose:
				Takes an area, goes over for the values 1 - 9 and tries to find if it has a spot appropriate for that value.

				calls is_appropriate tons of times.

		solve_grid:
			uses grid traversal to go over each chamber, row and column.

			uses solve_area to solve that area for what it can.

			Repeat until the board is as complete as this basic algorithm can solve for.



